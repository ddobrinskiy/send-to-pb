# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_mail.ipynb (unless otherwise specified).

__all__ = ['MessageEncoded', 'SCOPES', 'Emailer']

# Cell
from dataclasses import dataclass
from typing import Optional
import base64
import os
import os.path
import pathlib
import pickle

from email.mime.application import MIMEApplication
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import fastcore.test
import mimetypes

import send_to_pb.utils as u


# Cell

# If modifying these scopes, delete the file token.pickle.
SCOPES = [
            'https://www.googleapis.com/auth/gmail.send',
            'https://www.googleapis.com/auth/gmail.readonly',
         ]


@dataclass
class MessageEncoded:
    raw: str
    to: str

    def json(self):
        return {"raw": self.raw}

# Cell

class Emailer:
    def __init__(self):
        self.service = self.g_auth()

    def g_auth(self):
        """authorise in Google using creds
        """
        creds_location = pathlib.Path('~/credentials/gmail_api_creds.json') \
                                .expanduser()
        token_dir = pathlib.Path('~/.tokens') \
                                .expanduser()
        if not token_dir.exists():
            token_dir.mkdir()
        token_location = token_dir/'gmail_api_token.pickle'


        creds = None
        # The file token.pickle stores the user's access and refresh tokens, and is
        # created automatically when the authorization flow completes for the first
        # time.
        if token_location.exists():
            with open(token_location, 'rb') as token:
                creds = pickle.load(token)
        # If there are no (valid) credentials available, let the user log in.
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(
                    creds_location,
                    SCOPES)
                creds = flow.run_local_server(port=0)
            # Save the credentials for the next run
            with open(token_location, 'wb') as token:
                pickle.dump(creds, token)

        service = build('gmail', 'v1', credentials=creds)
        return service


    def _create_message_with_attachment(self,
                                       file:pathlib.Path,
                                       message_text:str = '',
                                       sender:str="David",
                                       to:str="dzlob@pbsync.com",
                                       subject:str="SEND TO PBSYNC",
                                       ) -> MessageEncoded:

        if not file.is_file():
            raise FileNotFoundError(file)

        message = MIMEMultipart()
        message['to'] = to
        message['from'] = sender
        message['subject'] = subject

        if message_text == '':
            message_text = "# THIS MESSAGE WAS AUTOGENERATED BY SEND_TO_PB"
        message.attach(
            MIMEText(message_text)
            )

        content_type, encoding = mimetypes.guess_type(file)

        if content_type is None or encoding is not None:
            content_type = 'application/octet-stream'

        main_type, sub_type = content_type.split('/', 1)

        if main_type == 'text':
            fp = open(file, 'rb')
            msg = MIMEText(fp.read().decode("utf-8"), _subtype=sub_type)
            fp.close()

        elif main_type == 'application' and sub_type == 'pdf':
            temp = open(file, 'rb')
            msg = MIMEApplication(temp.read(), _subtype=sub_type)
            temp.close()
        elif main_type == 'image':
            fp = open(file, 'rb')
            msg = MIMEImage(fp.read(), _subtype=sub_type)
            fp.close()
        elif main_type == 'audio':
            fp = open(file, 'rb')
            msg = MIMEAudio(fp.read(), _subtype=sub_type)
            fp.close()
        else:
            fp = open(file, 'rb')
            msg = MIMEBase(main_type, sub_type)
            msg.set_payload(fp.read())
            fp.close()
        filename = os.path.basename(file)
        msg.add_header('Content-Disposition', 'attachment', filename=filename)
        message.attach(msg)

        ## Part 4 encode the message (the message should be in bytes)
        message_as_bytes = message.as_bytes() # the message should converted from string to bytes.
        message_as_base64 = base64.urlsafe_b64encode(message_as_bytes) #encode in base64 (printable letters coding)

        raw = message_as_base64.decode()  # need to JSON serializable (no idea what does it means)
        return MessageEncoded(raw=raw, to=to)


    def _send_message(self, content:MessageEncoded, user_id:Optional[str]=''):
        if user_id == '':
            user_id = 'david.dobrinskiy@gmail.com'

        try:
            gmail_message = (self.service
                             .users()
                             .messages()
                             .send(userId=user_id, body=content.json())
                             )
            gmail_message.execute()
            u.logger.info(f"Gmail message sent to {content.to}")
            return gmail_message
        except Exception as e:
            u.logger.error(f'An error occurred: {e}')
            return None

    def send_file(self,
                  file:pathlib.Path,
                  to:str="dzlob@pbsync.com",
                  ) -> bool:
        content = self._create_message_with_attachment(file=file,
                                                      to=to,
                                                     )
        self._send_message(content=content)

        return True

