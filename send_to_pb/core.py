# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['get_arxiv_pdf_url', 'download_file', 'is_url', 'TargetType', 'Target']

# Cell

from urllib.parse import urlparse
import pathlib

from bs4 import BeautifulSoup
from tqdm import tqdm
import fastcore.test
import fastcore.utils
import requests

from send_to_pb import utils as u

# Cell
def get_arxiv_pdf_url(url) -> (str, str):
    url = url.strip('/')
    if urlparse(url).path.startswith("/pdf/"):
        title = url.split('/')[-1]
        if not title.endswith('.pdf'):
            title += '.pdf'
        return url, title
    elif urlparse(url).path.startswith("/abs/"):
        u.logger.debug(f"Getting ARXIV link to parse {url}")
        content = fastcore.utils.urlread(url)
        u.logger.debug("OK")
        soup = BeautifulSoup(content, 'html.parser')
        u.logger.debug(f"Parsing {url}")

        title = soup.find('title').contents[0]
        u.logger.debug(f"Title found: {title}")

        href = soup.find("a", class_="abs-button download-pdf").get('href')
        u.logger.debug(f"href to pdf found: {href}")

        scheme, netloc =  urlparse(url).scheme, urlparse(url).netloc
        url_pdf = f"{scheme}://{netloc}{href}"
        return url_pdf, f"{title}.pdf"
    else:
        u.logger.error(f"This line should never run, check your url: {url}")
        raise Exception("This line should never run, check your url")

# Cell
def download_file(url:str, dest:pathlib.Path):
    u.logger.debug(f"downloading to {dest}")
    r = requests.get(url, stream=True, allow_redirects=True)
    total_size = int(r.headers.get('content-length'))
    initial_pos = 0
    with open(dest, 'wb') as f:
        with tqdm(total=total_size,
                  unit='iB',
                  unit_scale=True,
                  desc=dest.name,
                  initial=initial_pos,
                  ) as pbar:
            for ch in r.iter_content(chunk_size=1024):
                if ch:
                    f.write(ch)
                    pbar.update(len(ch))

# Cell
def is_url(s):
    result = urlparse(s)
    if result.scheme:
        return True
    else:
        return False

# Cell

from enum import Enum

class TargetType(Enum):
    LOCAL_FILE = 'LOCAL_FILE'
    LOCAL_DIR = 'LOCAL_DIR'
    URL_ARXIV = 'URL_ARXIV'
    URL_OTHER = 'URL_OTHER'
    NOT_FOUND = 'NOT_FOUND'


class Target:
    def __init__(self, input_str:str):
        self.input = input_str
        self.type = self.get_type(input_str)

        self.validate()

    def get_type(self, s:str) -> TargetType:
        if is_url(s):
            if urlparse(s).netloc == 'arxiv.org':
                return TargetType.URL_ARXIV
            else:
                return TargetType.URL_OTHER

        else:
            if pathlib.Path(s).is_file():
                return TargetType.LOCAL_FILE
            elif pathlib.Path(s).is_dir():
                return TargetType.LOCAL_DIR
            else:
                return TargetType.NOT_FOUND

    def validate(self):
        if self.type not in [TargetType.URL_ARXIV]:
            raise NotImplementedError(f"{self.type.name} targets")

    def fetch_target(self):
        if self.type == TargetType.URL_ARXIV:
            url_pdf, title = get_arxiv_pdf_url(self.input)

            dest_dir = pathlib.Path("~/Downloads/send_to_pb").expanduser()
            if not dest_dir.exists():
                u.logger.info(f"Creating target directory: {dest_dir}")
                dest_dir.mkdir(exist_ok=True)

            dest = dest_dir/title
            download_file(url_pdf, dest)
            self.fetched_path = dest
            return dest

        else:
            raise NotImplementedError(f"{self.type.name} targets")

    __repr__ = fastcore.utils.basic_repr('input, type')
