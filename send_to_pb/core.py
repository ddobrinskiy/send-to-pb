# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['get_arxiv_pdf_url', 'download_file', 'is_url', 'TargetType', 'Target']

# Cell

from urllib.parse import urlparse
import pathlib

from bs4 import BeautifulSoup
from tqdm import tqdm
import fastcore.test
import fastcore.utils
import requests

from send_to_pb import utils as u

# Cell
def get_arxiv_pdf_url(url) -> (str, str):
    url = url.strip('/')
    if urlparse(url).path.startswith("/pdf/"):
        u.logger.debug("Direct pdf link to ARXIV detected, replatincg to /abs/")
        url = url.replace("/pdf/", "/abs/")

    if urlparse(url).path.startswith("/abs/"):
        u.logger.debug(f"Getting ARXIV link to parse {url}")
        content = fastcore.utils.urlread(url)
        u.logger.debug("OK")
        soup = BeautifulSoup(content, 'html.parser')
        u.logger.debug(f"Parsing {url}")

        title = soup.find('title').contents[0]
        u.logger.debug(f"Title found: {title}")

        href = soup.find("a", class_="abs-button download-pdf").get('href')
        u.logger.debug(f"href to pdf found: {href}")

        scheme, netloc =  urlparse(url).scheme, urlparse(url).netloc
        url_pdf = f"{scheme}://{netloc}{href}"
        return url_pdf, f"{title}.pdf"
    else:
        u.logger.error(f"This line should never run, check your url: {url}")
        raise Exception("This line should never run, check your url")

# Cell
def download_file(url:str, dest:pathlib.Path):
    u.logger.debug(f"downloading to {dest}")
    r = requests.get(url, stream=True, allow_redirects=True)
    total_size = int(r.headers.get('content-length'))
    initial_pos = 0
    with open(dest, 'wb') as f:
        with tqdm(total=total_size,
                  unit='iB',
                  unit_scale=True,
                  desc=dest.name,
                  initial=initial_pos,
                  ) as pbar:
            for ch in r.iter_content(chunk_size=1024):
                if ch:
                    f.write(ch)
                    pbar.update(len(ch))

# Cell
def is_url(s):
    result = urlparse(s)
    if result.scheme:
        return True
    else:
        return False

# Cell

from enum import Enum

class TargetType(Enum):
    LOCAL_FILE = 'LOCAL_FILE'
    LOCAL_DIR = 'LOCAL_DIR'
    URL_ARXIV = 'URL_ARXIV'
    URL_OTHER = 'URL_OTHER'
    NOT_FOUND = 'NOT_FOUND'


class Target:
    def __init__(self, input_str:str):
        self.input = input_str
        self.type = self.get_type(input_str)
        self.fetch_target()

    def get_type(self, s:str) -> TargetType:
        if is_url(s):
            if urlparse(s).netloc == 'arxiv.org':
                return TargetType.URL_ARXIV
            else:
                return TargetType.URL_OTHER

        else:
            if pathlib.Path(s).is_file():
                return TargetType.LOCAL_FILE
            elif pathlib.Path(s).is_dir():
                return TargetType.LOCAL_DIR
            else:
                u.logger.warning(f"Can't find {s}")
                return TargetType.NOT_FOUND

    def fetch_target(self):
        if self.type == TargetType.URL_ARXIV:
            url_pdf, title = get_arxiv_pdf_url(self.input)

            dest_dir = pathlib.Path("~/Downloads/send_to_pb").expanduser()
            if not dest_dir.exists():
                u.logger.info(f"Creating target directory: {dest_dir}")
                dest_dir.mkdir(exist_ok=True)

            dest = dest_dir/title
            if dest.is_file():
                # file exists already
                u.logger.info(f"File already exists, skipping download {dest}")
            else:
                # file does not exist, let's download it
                download_file(url_pdf, dest)

            self.files = [dest]
            return self.files

        elif self.type == TargetType.LOCAL_FILE:
            self.files = [pathlib.Path(self.input)]
            u.logger.info(f"Will send a local file from {self.files[0]}")
            return self.files

        elif self.type == TargetType.LOCAL_DIR:
            allowed_file_types = ['epub', 'mobi', 'pdf', 'fb2']
            dir_ = pathlib.Path(self.input)
            files = [fp for fp in dir_.rglob('*') if fp.name.split('.')[-1] in allowed_file_types]
            u.logger.info(f"{len(files)} files found in {dir_}:")
            for fp in files:
                u.logger.info(f">> {fp}")

            self.files = files
            return files

        else:
            raise NotImplementedError(f"{self.type.name} targets")

    def __repr__(self):
        return f"Target(input={self.input}, type={self.type}, nbr_files=#{len(self.files)})"
